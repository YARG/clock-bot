import threading
from collections import defaultdict


class Cache:
    """
    This is a thread-safe cache in the fact that it cannot go corrupt.
    However, item generation is not thread-safe and if multiple thread call it concurrently for the same key,
    that may lead to a single item being generated more than once (but only one will be stored
    on the cache).

    If you want to ensure items are only generated once, use `SynchronizedCache`.

    Use this cache when generate functions are quick and the lock overhead that `SynchronizedCache` has
    does not compensate a possible double generation for an item.
    """

    def __init__(self):
        # we rely on dicts being thread-safe:
        # https://stackoverflow.com/questions/6953351/thread-safety-in-pythons-dictionary
        self.cache = {}

    def get_or_generate(self, key, generate_func: callable):
        value = self.cache.get(key)
        if value is None:
            self.cache[key] = value = generate_func()
        return value

    def is_cached(self, key):
        return key in self.cache

    def cached_keys(self):
        return self.cache.keys()


class SynchronizedCache(Cache):
    """
    Thread safe cache that ensures items are only generated once.

    The get_or_generate function has a quick path when an item is already cached that does not require locking.
    However, if the item is not already cached, there is a lock acquire-release overhead to ensure
    that the item is only generated once.

    The lock used is per-item, so different items can be generated by multiple threads at the same time
    without problem (we rely on `Cache` to do it safely).

    Use this cache when the generate function is so time-consuming that the possibility of duplicate generation
    is high and undesirable. Note that if generation is quick, the lock overhead must be taken into account
    as it will be acquired for every item generated.
    """

    def __init__(self):
        super().__init__()
        # one lock per key
        self.locks = defaultdict(threading.Lock)

    def get_or_generate(self, key, generate_func: callable):
        # quick path: if value is in dict, return it
        value = self.cache.get(key)
        if value is not None:
            return value
        # slow path: value was not in dict, get lock to be sure to generate it only once
        with self.locks[key]:
            # with lock acquired we need to check again if key is in dict before inserting
            # because it could have been added between the unlocked check and the lock acquire
            value = super().get_or_generate(key, generate_func)
            self._remove_lock(key)
            return value

    def _remove_lock(self, key):
        """
        Once a key has been generated, we can remove the lock acquired to generate it,
        so that its memory can be released.
        It won't be used any longer, as next calls for the key will get through the quick path.
        But there could be some edge cases, described below:
          - There are threads waiting to acquire it. In this case, the threads will keep waiting,
            as we are only removing the key from the dict, not the lock itself. Once they acquire
            it, they will also try to remove the lock, so we must not fail in those cases (double
            freeing the same key).
          - After removing the lock from the dict, a thread that did not go through the quick path
            (because it made the check before having the result generated) tries to get the lock.
            In that case, a new lock will be allocated for the key. But, as the value has already
            been generated, once the thread acquire the new lock and check again if the value
            exists, it will find it on the cache. Later, that lock will be removed too.
        """
        try:
            del self.locks[key]
        except KeyError:
            pass
