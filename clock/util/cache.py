import threading
from collections import defaultdict


class Cache:
    """
    This is a thread-safe cache in the fact that it cannot go corrupt.
    However, item generation is not thread-safe and if multiple thread call it concurrently for the same key,
    that may lead to a single item being generated more than once (but only one will be stored
    on the cache).

    If you want to ensure items are only generated once, use `SynchronizedCache`.

    Use this cache when generate functions are quick and the lock overhead that `SynchronizedCache` has
    does not compensate a possible double generation for an item.
    """

    def __init__(self):
        # we rely on dicts being thread-safe:
        # https://stackoverflow.com/questions/6953351/thread-safety-in-pythons-dictionary
        self.cache = {}

    def get_or_generate(self, key, generate_func: callable):
        value = self.cache.get(key)
        if value is None:
            self.cache[key] = value = generate_func()
        return value

    def is_cached(self, key):
        return key in self.cache

    def cached_keys(self):
        return self.cache.keys()


class SynchronizedCache(Cache):
    """
    Thread safe cache that ensures items are only generated once.

    The get_or_generate function has a quick path when an item is already cached that does not require locking.
    However, if the item is not already cached, there is a lock acquire-release overhead to ensure
    that the item is only generated once.

    The lock used is per-item, so different items can be generated by multiple threads at the same time
    without problem (we rely on `Cache` to do it safely).

    Use this cache when the generate function is so time-consuming that the possibility of duplicate generation
    is high and undesirable. Note that if generation is quick, the lock overhead must be taken into account
    as it will be acquired for every item generated.
    """

    def __init__(self):
        super().__init__()
        # one lock per key
        self.locks = defaultdict(threading.Lock)

    def get_or_generate(self, key, generate_func: callable):
        # quick path: if value is in dict, return it
        value = self.cache.get(key)
        if value is not None:
            return value
        # slow path: value was not in dict, get lock to be sure to generate it only once
        with self.locks[key]:
            # with lock acquired we need to check again if key is in dict before inserting
            # because it could have been added between the unlocked check and the lock acquire
            return super().get_or_generate(key, generate_func)
